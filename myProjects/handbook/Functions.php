<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="utf-8">
    <title>Функции</title>
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <header>
      <p class="page-title">Функции</p>
      <nav class="blog-navigation">
        <a href="index.html">На главную</a>
      </nav>
    </header>
      <article>
        <h1>Функции</h1>
        <p>Вы уже много раз использовали функции. Особенно часто вы использовали функции, когда работали с массивами: узнавали количество элементов в массивах, узнавали первый и последний элементы, проверяли существование по индексу и так далее. Но чем на самом деле является функции и в чём их назначение, мы ещё не изучали.</p>
        <p class="rule"> &nbsp <em><b>Функция</b></em> — блок кода, подпрограмма, которая может быть именована и вызвана повторно</p>
        <h2>Назначение функций</h2>
        <p>Функцией будет называться некий блок кода, который можно вызвать по его имени. Этот блок кода, когда вызывается по имени, должен выполнить одну простую задачу. Главное назначение функции — сделать код сценария короче и понятнее.</p>
        <p>Функции изолируют блок кода и позволяют выполнить этот блок когда потребуется, обратившись к нему по имени.</p>
        <p>Вместо того чтобы писать все действия самостоятельно, часть из них можно либо поручить стандартной функции, либо написать свою и использовать её по необходимости.</p>
        <p>Назначение функции — изолировать блок кода так, чтобы его можно было вызывать в разных местах. Также, как и переменные, которые вы можете вызвать по имени, но переменные хранят значения, а функции хранят код.</p>
        <h2>Специализация функции</h2>
        <img src="picture/f1.jpg" alt="циклы" width="800">
        <p class="signature">Рисунок 1. У каждой функции должна быть своя чёткая специализация</p>
        <p>Важная характеристика функции — её специализация. Функция всегда делает что-то одно, одну изолированную задачу. Если вы напишете много узкоспециализированных функций, то их можно комбинировать по-разному, а сами функции будут короткими. Такие функции получится использовать в разных сценариях вашего проекта и даже в разных проектах. Каждая функция должна выполнять одну задачу, а все вместе они выполняют крупную работу.</p>
        <h2>Виды функций</h2>
        <h3>Пользовательские</h3>
        <ul>
            <li>Определяются программистом;</li>
            <li>Используются как часть сценария;</li>
            <li>Не имеют документирования.</li>
        </ul> 
        <h3>Стандартные</h3>
        <ul>
            <li>Уже существуют в языке;</li>
            <li>Нужны для решения общих задач;</li>
            <li>Хорошо документированы.</li>
        </ul>                   
        <p>Функции бывают двух видов: те, что есть в языке и те, что вы пишите самостоятельно. Функции, которые вы пишите самостоятельно, называются пользовательскими. Вы их используете внутри своих сценариев, самостоятельно их описываете, даёте имя и у них нет документации, разве что вы сами об этом не позаботитесь.</p>
        <p>И есть стандартные функции, встроенные в язык PHP. Вы можете их просто использовать по имени. Они все подробно расписаны в документации и нужны для решения общих задач. Допустим, подсчёт элементов в массиве или показ информации на экране. Набор всех встроенных в язык функций называется стандартной библиотекой.</p>
        <p>Стандартная библиотека PHP — огромное количество (~ 2000) встроенных функций на все случаи жизни</p>
        <img src="picture/spl.png" alt="циклы" width="800">
        <p class="signature">Рисунок 2. Стандартная библиотека PHP</p>        
        <p>Стандартная библиотека PHP содержит больше 2000 функций, которые делятся на группы. Все группы с описанием можно посмотреть в официальной документации. Обратитесь к справочнику функций, прежде чем писать код для решения задачи самостоятельно</p>
        <p>Зная о том, что в PHP множество стандартных функций, а также что все они описаны в документации, вы должны понимать: перед тем, чтобы что-то реализовать, стоит подумать и поискать, вдруг есть функция, которая поможет полностью или частично решить эти задачи.</p>
        <h3>Категории стандартных функций</h3>
        <ul>
            <li>Работа со строками;</li>
            <li>Дата и время;</li>
            <li>Работа с файлами и каталогами;</li>
            <li>Математические функции;</li>
            <li>Запуск внешних программ;</li>
            <li>Графика;</li>
            <li>Базы данных;</li>
            <li>Работа с архивами;</li>
        </ul> 
        <p>Так как функции распределены по категориям, легко понять, есть ли среди них те, что вам нужны. Скажем, если вы работаете со строками, то можно пойти в раздел функций для работы со строками и найти подходящие. Есть функции для работы с датой, временем, файлами и каталогами. А также математическими действиями, запуском внешних программ, для работы с графиками, базами данных, архивами и так далее.</p>
        <h3>Как найти подходящую стандартную функцию</h3>
        <p>Google — ваш друг. Вбейте в поиск на английском что должна делать функция и  перейдите по первой ссылке.</p>
        <img src="picture/google.png" alt="циклы" width="800">
        <p class="signature">Рисунок 3. Поиск стандартной функции в Google</p>
        <p>Как найти функцию, если не знаешь о её существовании? Достаточно поискать в Гугле: пишете «PHP function», а дальше описание того, что она делает. Предположим, мы хотим узнать есть ли функция, которая переводит массив в строку. Забиваем это в поисковик, и сразу первая ссылка — то, что нам нужно в документации, функция &nbsp <span class="codeLine"> &nbsp implode &nbsp </span> &nbsp. </p>
        <h2>Пользовательские функции</h2>        
        <p>Как вы уже поняли, в PHP есть большая встроенная библиотека функций, но в этой главе больше внимание уделяется тому, что разработчик пишет самостоятельно — пользовательским функциям.</p>
        <h3>Определение пользовательской функции</h3>
        <img src="picture/function.png" alt="циклы" width="800">
        <p class="signature">Рисунок 4. Синтаксис определения новой функции</p>
        <p>Как определить свою новую функцию? Для этого есть ключевое слово &nbsp <span class="codeLine"> &nbsp function &nbsp </span> &nbsp , после которого идёт уникальное имя функции. Требования к именованию функций такие же, как и к переменным, только не нужен знак доллара. Дальше идут круглые скобки, в них могут быть или отсутствовать аргументы, тело функции, то есть тот блок, который будет выполнен при её вызове находится внутри фигурных скобок. Также функция может что-то возвращать.</p>
        <h3>Свойства функций</h3>
        <ul>
            <li>Нужны, чтобы избежать дублирования кода;</li>
            <li>Результат выполнения может быть присвоен переменной;</li>
            <li>Функция может возвращать результат;</li>
            <li>Может принимать аргументы;</li>
            <li>Создаёт свою область видимости.</li>
        </ul>
        <p>Что отличает функции от остального кода? Функция — это блок кода, который мы огородили и дали ему имя. В функцию помещается код, который можно использовать больше одного раза.</p>
        <p>Допустим, у вас есть некий блок кода, который используется для форматирования заголовков. Такая потребность возникает на разных страницах вашего сайта. Это значит, что код для форматирования заголовков можно оформить в виде функции.</p>
        <p>Важное свойство функции: она может либо возвращать, либо не возвращать результат. Мы много раз использовали функции для работы с массивами и то, что они возвращали, как правило, присваивалось переменной. Допустим, функция &nbsp <span class="codeLine"> &nbsp count &nbsp </span> &nbsp  вернёт число, которое после присвоили переменной. Но не все функции возвращают результат. Некоторые функции могут просто что-то молча делать. Допустим, функция &nbsp <span class="codeLine"> &nbsp print &nbsp </span> &nbsp , которая ничего не возвращает, но выводит информацию на экран.</p>
        <p>Функция также может принимать аргументы. Функция &nbsp <span class="codeLine"> &nbsp count &nbsp </span> &nbsp  принимает в аргументы массив, который вы ей должны передать. Каждая из функций, которые мы использовали, принимала какие-то аргументы.</p>
        <h2>Область видимости</h2>
        <p class="rule"> &nbsp <em><b>Область видимости</b></em> — это контекст, внутри которого переменная была определена и где к ней можно получить доступ</p>
        <p>То, что находится внутри функции, имеет свою ограниченную область видимости. И код, который там находится может видеть и работать только с переменными, которые находятся внутри той же функции.</p>
        <h3>Свойства области видимости</h3>
        <ul>
            <li>Переменные, определённые за пределами функции называются «внешними»;</li>
            <li>Переменные, определённые внутри функции называются «внутренними»;</li>
            <li>Внутри функции внешние переменные не видны;</li>
            <li>Чтобы передать внешние переменные внутрь функции, нужно использовать аргументы.</li>
        </ul>
        го<h3>Аргументы и область видимости</h3>
        <p>Возьмём обычный PHP-сценарий. В нём есть переменные, которые вы определили, также там вы определили функцию, внутри которой также есть переменные. Переменные, которые внутри функции называются <b>внутренними</b>, а которые снаружи — <b>внешними</b>.</p>
        <p>Внешние переменные внутри функции не видны, и наоборот. Чтобы организовать связь между внешним кодом и функцией, то есть чтобы внутрь функций что-то попало из внешнего кода, используются <b>аргументы</b>.</p>
        <img src="picture/mario.png" alt="циклы" width="1000">
        <p class="signature">Рисунок 5. Марио помогает разобраться с аргументами функции</p>
        <p>Аргумент — это такая труба, которая позволяет в функцию, спрятанную под землей, передать какие-то данные сверху. Труба — аргумент, а Марио — значение, которое мы в этот аргумент передаем. То есть у нас есть функция со своей областью видимостью и переменными: это называется внутренней областью видимости. Внешний код, в свою очередь, означает всё, что находится снаружи функции.</p>
        <p>Чтобы передать что-то внутрь, нужно сначала определить аргумент, а потом в этот аргумент отправить какое-то значение.</p>
        <h3>Пример функции и области видимости</h3>
        <img src="picture/scope.png" alt="циклы" width="1100">
        <p class="signature">Рисунок 6. Объяснение области видимости на примере функции с аргументами</p>
        <p>Давайте разработаем функцию, которая будет форматировать текст. Это будет умная функция. Она должна сделать из строки заголовок, если ей передали строку, а вот если ей передали массив, то она все элементы массива сделает элементами тегов &nbsp <span class="codeLine"> &nbsp li &nbsp </span> &nbsp и поместит внутрь тегов &nbsp <span class="codeLine"> &nbsp ul &nbsp </span> &nbsp. Это нужно, чтобы быстро показывать массивы в HTML.</p>
        <p>Всё, что находится снаружи — внешняя область видимости. А всё, что внутри — внутренняя. У нас есть две переменных — &nbsp <span class="codeLine"> &nbsp $cats &nbsp </span> &nbsp и &nbsp <span class="codeLine"> &nbsp $page_title &nbsp </span> &nbsp. Они объявлены во внешнем коде и внутри функции недоступны. Если мы попытаемся к ним обратиться, то мы получим ошибку.</p>
        <p>Но чтобы нам их передать внутрь и получить результат, мы определили аргумент, дали ему название &nbsp <span class="codeLine"> &nbsp $input &nbsp </span> &nbsp. Это означает, что элемент с названием &nbsp <span class="codeLine"> &nbsp $input &nbsp </span> &nbsp станет внутренней переменной и переменную &nbsp <span class="codeLine"> &nbsp $input &nbsp </span> &nbsp можно использовать.</p>
        <p>Если мы внутрь &nbsp <span class="codeLine"> &nbsp $input &nbsp </span> &nbsp передадим &nbsp <span class="codeLine"> &nbsp $page_title &nbsp </span> &nbsp  или &nbsp <span class="codeLine"> &nbsp $cats &nbsp </span> &nbsp , тогда функция получит это значение и сможет с ними работать. То есть мы определили аргумент и при вызове функции помещаем в него внешние переменные.</p>
        <h3>Зачем функции своя область видимости</h3>
        <p>Это нужно для того, чтобы функция не влияла на внешний код. Идея заключается в том, что функция делает только свою работу и не должна ни на что другое отвлекаться и не мешать другим функциям и другому коду. Поэтому функция изолирована в свою область видимости и никак не может трогать другой код.</p>
        <p>Сделано это для того, чтобы у функции была чёткая специализация. Если у каждой функции есть такая специализация, то вместо того, чтобы писать код внутри одного гигантского сценария, мы дробим его на отдельные функции, каждая из которых делает своё дело и мы используем их совместно, чтобы получить результат.</p>
        <img src="picture/functions.png" alt="циклы" width="1100">
        <p class="signature">Рисунок 7. Узкая специализации функции — это благо</p>
        <h3>Функция как контракт</h3>
        <img src="picture/contract.png" alt="циклы" width="1100">
        <p class="signature">Рисунок 8. Функция как юридический контракт</p>
        <p>Если смотреть на функцию не просто как на некий блок кода, а как на двух контрагентов, которые выполняют поручения по определённому договору, то мы сможем более грамотно дробить код на функции и весь код будет более качественным, расширяемым и поддерживаемым.</p>
        <p>Мы будем использовать «договорной подход» к функциям. Суть этого подхода в том, что функция, по-сути, является договором. В договоре есть отдельные разделы.</p>
        <p>Мы определим, что является функцией, какое у неё будет имя и что она должна сделать. Имя — это уникальное название, по которому к ней можно обращаться.</p>
        <p>Что функция должна делать: к этому мы приходим в голове, а потом описываем алгоритмом или в коде. Дальше мы определяем, какие ей понадобятся данные, они станут аргументами и эти аргументы должны быть явными: что это за аргумент, какого типа и для чего он нужен.</p>
        <p>И последнее: должна ли функция что-то вернуть. И какой должен быть результат её работы. Если функция что-то возвращает, то что конкретно: какого типа и так далее. Если ничего, то это тоже надо заранее продумать.</p>
        <h2>Дополнительные возможности функций</h2>
        <h3>Аргументы по умолчанию</h3>
        <p>Аргументам функции можно указать значения по умолчанию. Аргумент будет иметь это значение, если при вызове  функции в него ничего не передадут.</p>
        <p><b>Объявление функции:</b></p>
        <pre><code>
            &lt;?php

            function random_code($symbols, $length = 8) {
                if (is_array($symbols)) {
                    $str = "";

                    while ($length) {
                        $key = array_rand($symbols);
                        $str .= $symbols[$key];

                        $length--;
                    }

                    return $str;
                }
            }
        </code></pre>
        <p>Здесь мы установили значение аргумента &nbsp <span class="codeLine"> &nbsp $input &nbsp </span> &nbsp по умолчанию равным 8.</p>
        <h3>Вызов функции</h3>
        <pre><code>
            &lt;?php
            $sequence = [0,1,2,3,4,5,6,7,8,9];

            $eight_digit = random_code($sequence);
            $ten_digits = random_code($sequence, 10);
        </code></pre>
        <p>При вызове функции теперь  необязательно указывать значение аргумента</p>
        <h3>Указание типа аргументов</h3>        
        <p>Аргументам функции можно указать допустимый тип. PHP будет при необходимости пытаться привести  значение аргумента к этому типу.</p>
        <pre><code>
            &lt;?php
            function random_code(array $symbols, $length = 8) {
                $str = "";

                while ($length) {
                    $key = array_rand($symbols);
                    $str .= $symbols[$key];

                    $length--;
                }

                return $str;
        }
        </code></pre>
        <p>Аргументу функции можно указать не только значение по умолчанию, но ещё и его тип: строка, число и так далее. В примере выше функция ожидает, что $symbols будет массивом и это означает, что больше не нужно беспокоиться о проверке аргумента на массив. Мы указали, что аргумент &nbsp <span class="codeLine"> &nbsp $symbols &nbsp </span> &nbsp  будет массивом и PHP будет сам пытаться автоматически преобразовать аргумент в массив.</p>
        <h2>Анонимные функции</h2>
        <p>Есть ещё один вид пользовательских функций, которые вы можете определить: анонимные функции. Определяются они как обычно, за тем исключением, что у такой функции нет имени. Раз у функции нет имени, то как вызывать такую функцию и зачем вообще это нужно?</p>
        <h3>Особенности анонимных функций</h3>
        <ul>
            <li>не имеют своего имени;</li>
            <li>могут быть присвоены переменной;</li>
            <li>можно передать как аргумент;</li>
            <li>полезны в качестве «функций обратного вызова».</li>
        </ul>
        <p>Анонимную функцию можно присвоить переменной и вызвать ее по имени переменной. Также анонимную функцию можно передать в качестве аргумента в другую функцию. Чаще всего используется второй подход, когда мы передаем анонимную функцию в качестве аргумента другой функции.</p>
        <h3>Практика работы с анонимными функциями</h3>
        <p><b>Постановка задачи</b></p>
        <p>Написать такой код, который возьмёт массив с числами и оставит в этом массиве только чётные числа.</p>
        <p><b>Возможное решение</b></p>
        <p>Мы можем написать элементарную анонимную функцию, которая будет проверять число на чётность и возвращать &nbsp <span class="codeLine"> &nbsp true/false &nbsp </span> &nbsp . Затем эту функцию можно передать в качестве аргумента стандартной функции &nbsp <span class="codeLine"> &nbsp array_filter &nbsp </span> &nbsp .</p>
        <pre><code>
            &lt;?php
            $values = [5, 34, 8, 77, 104, 33, 91, 28, 6];

            $values = array_filter($values, function($val) {
                return $val % 2 == 0;
            });
        </code></pre>
        <p></p>
        <p></p>
        <p></p>
        <p></p>
        <p></p>
        <p></p>
        

        
        
        
        
        
        
        
        
        
        
      </article>
    <footer>
      <nav class="blog-navigation">
        <a href="index.html">На главную</a>
      </nav>
    </footer>
  </body>
</html>

